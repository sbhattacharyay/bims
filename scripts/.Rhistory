combined_models  <- train_caret_models(combined_train_CV,outcomes_avail,currTrainIdx,inner_cvIdx,classifier_choice)
if ('glmnet' %in% classifier_choice){
temp_classifier_choice<-replace(classifier_choice, classifier_choice == 'glmnet', 'glm')
clin_only_models <- train_caret_models(clin_only_train_CV,outcomes_avail,currTrainIdx,inner_cvIdx,temp_classifier_choice)
} else {
clin_only_models <- train_caret_models(clin_only_train_CV,outcomes_avail,currTrainIdx,inner_cvIdx,classifier_choice)
}
if ('glmnet' %in% classifier_choice & r==1){
temp_classifier_choice<-replace(classifier_choice, classifier_choice == 'glmnet', 'glm')
mf_only_models <- train_caret_models(mf_only_train_CV,outcomes_avail,currTrainIdx,inner_cvIdx,temp_classifier_choice)
} else {
mf_only_models <- train_caret_models(mf_only_train_CV,outcomes_avail,currTrainIdx,inner_cvIdx,classifier_choice)
}
# Determine optimal cutoff of each probability output by minimizing distance to optimal classifier (TPR = 1, FPR = 0) on training data
combined_self_val<-predict_caret_models(combined_models, combined_train_CV, outcomes_avail, currTrainIdx)
clin_only_self_val<-predict_caret_models(clin_only_models, clin_only_train_CV, outcomes_avail, currTrainIdx)
mf_only_self_val<-predict_caret_models(mf_only_models, mf_only_train_CV, outcomes_avail, currTrainIdx)
combined_self_preds[[i]] <- combined_self_val
clin_only_self_preds[[i]]  <- clin_only_self_val
mf_only_self_preds[[i]] <- mf_only_self_val
# Predict outcomes on testing data using trained models
combined_test_val<-predict_caret_models(combined_models, combined_test_CV, outcomes_avail, currTestIdx)
clin_only_test_val<-predict_caret_models(clin_only_models, clin_only_test_CV, outcomes_avail, currTestIdx)
mf_only_test_val<-predict_caret_models(mf_only_models, mf_only_test_CV, outcomes_avail, currTestIdx)
combined_predictions[[i]] <- combined_test_val
clin_only_predictions[[i]] <- clin_only_test_val
mf_only_predictions[[i]] <- mf_only_test_val
}
outList1 <-
list(
combined_predictions,
clin_only_predictions,
mf_only_predictions
)
names(outList1) <-
c(
"combined_predictions",
"clin_only_predictions",
"mf_only_predictions"
)
outList2 <-
list(
combined_self_preds,
clin_only_self_preds,
mf_only_self_preds
)
names(outList2) <-
c(
"combined_self_preds",
"clin_only_self_preds",
"mf_only_self_preds"
)
finalOutList <- list(outList1,outList2)
return(finalOutList)
}
out_12m<-classification_function(time_choice,time_slide,classifier_choice,outcomes_12m,mf_choice,sensor_loc)
preds_dis<-out_dis[[1]]
preds_12m<-out_12m[[1]]
preds_dis<-out_dis[[1]]
preds_12m<-out_12m[[1]]
self_dis<-out_dis[[2]]
self_12m<-out_12m[[2]]
cps_dis<-get_cutpoint(self_dis)
cps_12m<-get_cutpoint(self_12m)
cps_12m$combined_self_preds$Fold1$svmRadialWeights
cps_12m$combined_self_preds$Fold1$svmRadialWeights$optimal_cutpoint
cps_12m$combined_self_preds$Fold1$lda$optimal_cutpoint
cps_12m$combined_self_preds$Fold1$lda$AUC
plot(cps_12m$combined_self_preds$Fold1$lda)
plot(cps_12m$combined_self_preds$Fold1$glmnet)
cps_12m$combined_self_preds$Fold1$glmnet$ptimal_cutpoint
cps_12m$combined_self_preds$Fold1$glmnet$optimal_cutpoint
cps_12m$combined_self_preds$Fold1$glmnet$optimal_cutpoint
shmoopi <- get_cutpoint(preds_12m)
shmoopi$combined_predictions$Fold1$glmnet$optimal_cutpoint
get_cutpoint <- function(preds_set){
outputList <- list()
for (i in 1:length(preds_set)){
curr_pred_space <- preds_set[[i]]
pred_space_cps <- list()
n_folds <- length(curr_pred_space)
for (j in 1:length(curr_pred_space)){
curr_fold <- curr_pred_space[[j]]
modelNames <- colnames(curr_fold)
tru_levels <- levels(curr_fold[[1]])
fold_cps <- list()
for(m in 2:ncol(curr_fold)){
curr_cp <- cutpointr(curr_fold[[m]],
curr_fold[[1]],
direction = ">=",
pos_class = tru_levels[2],
neg_class = tru_levels[1],
method = minimize_metric,
metric = roc01,
break_ties = c)
fold_cps[[m-1]] = curr_cp
}
names(fold_cps) <- modelNames[2:length(modelNames)]
pred_space_cps[[j]] <- fold_cps
}
names(pred_space_cps) <- paste0(rep("Fold",n_folds),1:n_folds)
outputList[[i]] <- pred_space_cps
}
names(outputList) <- names(preds_set)
return(outputList)
}
cps_dis<-get_cutpoint(self_dis)
cps_12m<-get_cutpoint(self_12m)
cps_dis$combined_self_preds$Fold1$glmnet$optimal_cutpoint
cps_dis$combined_self_preds$Fold1$lda$optimal_cutpoint
shmoopi <- get_cutpoint(preds_12m)
shmoopi$combined_predictions$Fold1$glmnet$optimal_cutpoint
shmoopi$combined_predictions$Fold1$lda$optimal_cutpoint
get_cutpoint <- function(preds_set){
outputList <- list()
for (i in 1:length(preds_set)){
curr_pred_space <- preds_set[[i]]
pred_space_cps <- list()
n_folds <- length(curr_pred_space)
for (j in 1:length(curr_pred_space)){
curr_fold <- curr_pred_space[[j]]
modelNames <- colnames(curr_fold)
tru_levels <- levels(curr_fold[[1]])
fold_cps <- list()
for(m in 2:ncol(curr_fold)){
curr_cp <- cutpointr(curr_fold[[m]],
curr_fold[[1]],
direction = ">=",
pos_class = tru_levels[2],
neg_class = tru_levels[1],
method = minimize_metric,
metric = roc01,
break_ties = c)
fold_cps[[m-1]] = curr_cp
}
names(fold_cps) <- modelNames[2:length(modelNames)]
pred_space_cps[[j]] <- fold_cps
}
names(pred_space_cps) <- paste0(rep("Fold",n_folds),1:n_folds)
outputList[[i]] <- pred_space_cps
}
names(outputList) <- names(preds_set)
return(outputList)
}
preds_dis<-out_dis[[1]]
preds_12m<-out_12m[[1]]
self_dis<-out_dis[[2]]
self_12m<-out_12m[[2]]
# Determine optimal cutoff of each probability output by minimizing distance to optimal classifier (TPR = 1, FPR = 0)
cps_dis<-get_cutpoint(self_dis)
cps_12m<-get_cutpoint(self_12m)
View(cps_dis)
min
min(c(1,2,3,4))
min(c(.01,1,2,3,4))
get_cutpoint <- function(preds_set){
outputList <- list()
for (i in 1:length(preds_set)){
curr_pred_space <- preds_set[[i]]
pred_space_cps <- list()
n_folds <- length(curr_pred_space)
for (j in 1:length(curr_pred_space)){
curr_fold <- curr_pred_space[[j]]
modelNames <- colnames(curr_fold)
tru_levels <- levels(curr_fold[[1]])
fold_cps <- list()
for(m in 2:ncol(curr_fold)){
curr_cp <- cutpointr(curr_fold[[m]],
curr_fold[[1]],
direction = ">=",
pos_class = tru_levels[2],
neg_class = tru_levels[1],
method = minimize_metric,
metric = roc01,
break_ties = min)
fold_cps[[m-1]] = curr_cp
}
names(fold_cps) <- modelNames[2:length(modelNames)]
pred_space_cps[[j]] <- fold_cps
}
names(pred_space_cps) <- paste0(rep("Fold",n_folds),1:n_folds)
outputList[[i]] <- pred_space_cps
}
names(outputList) <- names(preds_set)
return(outputList)
}
self_cps_dis<-get_cutpoint(self_dis)
self_cps_12m<-get_cutpoint(self_12m)
preds_set<-preds_dis
self_cps_set<-self_cps_dis
outputList <- list()
curr_pred_space <- preds_set[[i]]
pred_space_cps <- list()
n_folds <- length(curr_pred_space)
i=1
curr_pred_space <- preds_set[[i]]
pred_space_cps <- list()
n_folds <- length(curr_pred_space)
length(preds_set)
length(curr_pred_space)
self_cps_set[[i]]
self_cps_set[[i]][[j]]
self_cps_set[[i]][[1]]
self_cps_set[[i]][[1]]
j=1
self_cps_set[[i]][[j]][[m-1]]
m=2
self_cps_set[[i]][[j]][[m-1]]
fix_test_cutpoint <- function(preds_set,self_cps_set){
outputList <- list()
for (i in 1:length(preds_set)){
curr_pred_space <- preds_set[[i]]
pred_space_cps <- list()
n_folds <- length(curr_pred_space)
for (j in 1:length(curr_pred_space)){
curr_fold <- curr_pred_space[[j]]
modelNames <- colnames(curr_fold)
tru_levels <- levels(curr_fold[[1]])
fold_cps <- list()
for(m in 2:ncol(curr_fold)){
curr_cp <- cutpointr(curr_fold[[m]],
curr_fold[[1]],
direction = ">=",
pos_class = tru_levels[2],
neg_class = tru_levels[1],
method = oc_manual,
cutpoint = self_cps_set[[i]][[j]][[m-1]]$optimal_cutpoint,
break_ties = min)
fold_cps[[m-1]] = curr_cp
}
names(fold_cps) <- modelNames[2:length(modelNames)]
pred_space_cps[[j]] <- fold_cps
}
names(pred_space_cps) <- paste0(rep("Fold",n_folds),1:n_folds)
outputList[[i]] <- pred_space_cps
}
names(outputList) <- names(preds_set)
return(outputList)
}
cps_dis<-fix_test_cutpoint(preds_dis,self_cps_dis)
cps_12m<-fix_test_cutpoint(preds_12m,self_cps_12m)
sens_dis <- get_sens_info(cps_dis)
sens_12m <- get_sens_info(cps_12m)
## Specificity
spec_dis <- get_spec_info(cps_dis)
spec_12m <- get_spec_info(cps_12m)
## Positive Predictive Value:
PPV_dis <- get_PPV_info(cps_dis)
PPV_12m <- get_PPV_info(cps_12m)
## Negative Predictive Value:
NPV_dis <- get_NPV_info(cps_dis)
NPV_12m <- get_NPV_info(cps_12m)
## Accuracy:
acc_dis <- get_acc_info(cps_dis)
acc_12m <- get_acc_info(cps_12m)
## AUC:
auc_dis <- get_auc_info(preds_dis)
auc_dis_ci <- get_auc_info_ci(preds_dis)
auc_12m <- get_auc_info(preds_12m)
auc_12m_ci <- get_auc_info_ci(preds_12m)
# Metric Plots (ROCs for AUC):
plot_metric_stripcharts(sens_dis,"Sensitivity (Dis)",'sens_dis.png')
plot_metric_stripcharts(sens_12m,"Sensitivity (12m)",'sens_12m.png')
plot_metric_stripcharts(spec_dis,"Specificity (Dis)",'spec_dis.png')
plot_metric_stripcharts(spec_12m,"Specificity (12m)",'spec_12m.png')
plot_metric_stripcharts(PPV_dis,"PPV (Dis)",'PPV_dis.png')
plot_metric_stripcharts(PPV_12m,"PPV (12m)",'PPV_12m.png')
plot_metric_stripcharts(NPV_dis,"NPV (Dis)",'NPV_dis.png')
plot_metric_stripcharts(NPV_12m,"NPV (12m)",'NPV_12m.png')
plot_metric_stripcharts(acc_dis,"Accuracy (Dis)",'acc_dis.png')
plot_metric_stripcharts(acc_12m,"Accuracy (12m)",'acc_12m.png')
?ppv
PPV_dis
NPV_dis <- get_NPV_info(cps_dis)
NPV_dis
cps_set<-cps_dis
outputDF <- data.frame()
for (i in 1:length(cps_set)){
curr_pred_space <- cps_set[[i]]
curr_pred_space_name <- names(cps_set)[i]
no_classifiers <- length(curr_pred_space$Fold1)
classifier_names <- names(curr_pred_space$Fold1)
value_DF <- data.frame()
for (j in 1:no_classifiers){
values <- c()
for (m in 1:length(curr_pred_space)){
curr_cp <- curr_pred_space[[m]][[j]]
curr_sens <- curr_cp$sensitivity
curr_prev <- curr_cp$prevalence
curr_spec <- curr_cp$specificity
curr_PPV <- (curr_sens*curr_prev)/((curr_sens*curr_prev)+((1-curr_spec)*(1-curr_prev)))
values <- c(values,curr_PPV)
}
newRow<-data.frame(classifier = classifier_names[j],
mean_value = mean(values),
std_value = sd(values),
values)
value_DF <- rbind(value_DF,newRow)
}
outputDF <- rbind(outputDF,data.frame(value_DF,pred_space=curr_pred_space_name))
}
outputDF
curr_spec
curr_sens
curr_prev
curr_cp$pos_class
curr_cp$method
curr_cp$roc_curve
plot(curr_cp)
curr_cp$optimal_cutpoint
curr_cp$data
source('./functions/load_patient_clinical_data.R')
source('./functions/update_clinicalVariableList.R')
source('./functions/get_motion_features.R')
source("./functions/load_tf_patient_covariates.R")
source("./functions/train_caret_models.R")
source("./functions/predict_caret_models.R")
# Load patient clinical data (sorts by PY numbering and corrects variable types)
patient_clinical_data <- load_patient_clinical_data()
# Load and update clinical variable list
clinicalVariableList <- update_clinicalVariableList()
# Load Motion Features Organized by Time of Day (TOD)
if (!exists("tod_motion_features")) {
tod_sensors <-
readMat('../tod_motion_feature_data/bed_corrected_imputed_complete_sensor_data.mat')$bed.corrected.sensors
tod_motion_features <- get_motion_features(do.call(rbind, tod_sensors))
}
# Load Motion Features Organized by Time from Recording (TFR)
if (!exists("tfr_motion_features")) {
tfr_sensors <-
readMat('../tfr_motion_feature_data/bed_corrected_imputed_complete_sensor_data.mat')$bed.corrected.sensors
tfr_motion_features <- get_motion_features(do.call(rbind, tfr_sensors))
}
# Load transformed covariates for both TOD and TFR
tod_tf_covariates <-load_tf_patient_covariates('../tod_motion_feature_data/tf_patient_covariates.csv')
tfr_tf_covariates <-load_tf_patient_covariates('../tfr_motion_feature_data/tf_patient_covariates.csv')
tod_sensor_idx_ranges <- split(1:77754, ceiling(seq_along(1:77754)/12959))
tod_fp2_idx_ranges    <- lapply(tod_sensor_idx_ranges, function(x) x+77754)
tfr_sensor_idx_ranges <- split(1:34554, ceiling(seq_along(1:34554)/5759))
tfr_fp2_idx_ranges    <- lapply(tfr_sensor_idx_ranges, function(x) x+34554)
tfr_range<-seq(5/3600,8,length.out=5759)
tod_range<-seq(as.POSIXct("2020-05-05 18:00:05"),as.POSIXct("2020-05-06 12:00:00"),length.out=12959)
sensor_options <- c("left_ank","left_el","left_wr","right_ank","right_el","right_wr")
classification_function <-function(time_choice,time_slide,classifier_choice,outcomes,mf_choice,sensor_loc){
avail_idx <- !is.na(outcomes)
avail_seq <- seq(length(avail_idx))[avail_idx]
patient_clinical_data_avail<-patient_clinical_data[avail_seq,]
tod_tf_covariates_avail<-tod_tf_covariates[avail_seq,]
tfr_tf_covariates_avail<-tfr_tf_covariates[avail_seq,]
tod_motion_features_avail<-lapply(tod_motion_features, function(x) x[avail_seq,])
tfr_motion_features_avail<-lapply(tfr_motion_features, function(x) x[avail_seq,])
outcomes_avail<-outcomes[avail_seq]
set.seed(123)
# Nested stratified cross-validation: Create 5 folds for outer cross-validation (training vs. testing)
k <- 5
outer_cvIdx <- createFolds(outcomes_avail,k,list = TRUE);
sensor_choice_Idxs <- match(sensor_loc,sensor_options)
if (time_choice == 'tod'){
sensor_idx_ranges<-lapply(tod_sensor_idx_ranges,function(x) x[tod_range >= time_slide[1] & tod_range <= time_slide[2]])
fp2_idx_ranges   <-lapply(tod_fp2_idx_ranges,function(x) x[tod_range >= time_slide[1] & tod_range <= time_slide[2]])
curr_sensor_Idx<-do.call(c, sensor_idx_ranges[sensor_choice_Idxs])
curr_fp_Idx<-c(curr_sensor_Idx,do.call(c, fp2_idx_ranges[sensor_choice_Idxs]))
curr_motion_features <- lapply(tod_motion_features_avail[mf_choice], function(x) x[,curr_sensor_Idx])
if ('freq_pairsFeats' %in% mf_choice) curr_motion_features$freq_pairsFeats <- tod_motion_features_avail$freq_pairsFeats[,curr_fp_Idx]
curr_motion_features <- do.call(cbind,curr_motion_features)
tf_covariates <- tod_tf_covariates_avail
} else {
sensor_idx_ranges<-lapply(tfr_sensor_idx_ranges,function(x) x[tfr_range >= time_slide[1] & tfr_range <= time_slide[2]])
fp2_idx_ranges   <-lapply(tfr_fp2_idx_ranges,function(x) x[tfr_range >= time_slide[1] & tfr_range <= time_slide[2]])
curr_sensor_Idx<-do.call(c, sensor_idx_ranges[sensor_choice_Idxs])
curr_fp_Idx<-c(curr_sensor_Idx,do.call(c, fp2_idx_ranges[sensor_choice_Idxs]))
curr_motion_features <- lapply(tfr_motion_features_avail[mf_choice], function(x) x[,curr_sensor_Idx])
if ('freq_pairsFeats' %in% mf_choice) curr_motion_features$freq_pairsFeats <- tfr_motion_features_avail$freq_pairsFeats[,curr_fp_Idx]
curr_motion_features <- do.call(cbind,curr_motion_features)
tf_covariates <- tfr_tf_covariates_avail
}
combined_self_preds <- vector(mode = "list", length = k)
clin_only_self_preds  <- vector(mode = "list", length = k)
mf_only_self_preds  <- vector(mode = "list", length = k)
combined_predictions <- vector(mode = "list", length = k)
clin_only_predictions  <- vector(mode = "list", length = k)
mf_only_predictions  <- vector(mode = "list", length = k)
for (i in 1:k) {
currTestIdx <- outer_cvIdx[[i]]
currTrainIdx <- seq(nrow(patient_clinical_data_avail))[-currTestIdx]
# Convert numeric to logical indexing
logicalTest <- rep(FALSE, nrow(patient_clinical_data_avail))
logicalTest[currTestIdx] <- TRUE
logicalTrain <- !logicalTest
train_tf_covariates <- tf_covariates[currTrainIdx,]
test_tf_covariates  <- tf_covariates[currTestIdx,]
# Nested stratified cross-validation: Create 4 folds for inner cross-validation (hyperparameter tuning)
inner_cvIdx <- createFolds(outcomes_avail[currTrainIdx], 4, returnTrain = T)
# Convert inner cross-validation indices to LOL-compatible cross-validation indices
lol_sets <- list()
for (q in 1:length(inner_cvIdx)){
tempList <- list(train = inner_cvIdx[[q]],
test = seq(length(outcomes_avail[currTrainIdx]))[!seq(length(outcomes_avail[currTrainIdx])) %in% inner_cvIdx[[q]]])
lol_sets[[as.character(q)]] <- tempList
}
# Note: on all trials, we found that r_opt = 1.
# # Tune LOL on the inner cross-validation set to find optimal dimension for reduction:
# LOL <- lol.xval.optimal_dimselect(curr_motion_features[currTrainIdx,], outcomes_avail[currTrainIdx], rs=c(1:3,5:6,10), lol.project.lol, sets=lol_sets)
# r <- LOL$optimal.r
r <- 1
LOL <- lol.project.lol(curr_motion_features[currTrainIdx,], outcomes_avail[currTrainIdx], r)
# Prepare training covariates
combined_train_CV<- cbind(train_tf_covariates$APACHE_risk,LOL$Xr[,1:r])
colnames(combined_train_CV)<-c('APACHE_risk',paste0(rep("MF.",r),1:r))
clin_only_train_CV<-as.matrix(combined_train_CV[,'APACHE_risk'])
mf_only_train_CV<-as.matrix(combined_train_CV[,paste0(rep("MF.",r),1:r)])
# Prepare testing covariates
combined_test_CV<- cbind(test_tf_covariates$APACHE_risk,curr_motion_features[currTestIdx,]%*%LOL$A[,1:r])
colnames(combined_test_CV)<-c('APACHE_risk',paste0(rep("MF.",r),1:r))
clin_only_test_CV<-as.matrix(combined_test_CV[,'APACHE_risk'])
mf_only_test_CV<-as.matrix(combined_test_CV[,paste0(rep("MF.",r),1:r)])
# Train models on training data
combined_models  <- train_caret_models(combined_train_CV,outcomes_avail,currTrainIdx,inner_cvIdx,classifier_choice)
if ('glmnet' %in% classifier_choice){
temp_classifier_choice<-replace(classifier_choice, classifier_choice == 'glmnet', 'glm')
clin_only_models <- train_caret_models(clin_only_train_CV,outcomes_avail,currTrainIdx,inner_cvIdx,temp_classifier_choice)
} else {
clin_only_models <- train_caret_models(clin_only_train_CV,outcomes_avail,currTrainIdx,inner_cvIdx,classifier_choice)
}
if ('glmnet' %in% classifier_choice & r==1){
temp_classifier_choice<-replace(classifier_choice, classifier_choice == 'glmnet', 'glm')
mf_only_models <- train_caret_models(mf_only_train_CV,outcomes_avail,currTrainIdx,inner_cvIdx,temp_classifier_choice)
} else {
mf_only_models <- train_caret_models(mf_only_train_CV,outcomes_avail,currTrainIdx,inner_cvIdx,classifier_choice)
}
# Determine optimal cutoff of each probability output by minimizing distance to optimal classifier (TPR = 1, FPR = 0) on training data
combined_self_val<-predict_caret_models(combined_models, combined_train_CV, outcomes_avail, currTrainIdx)
clin_only_self_val<-predict_caret_models(clin_only_models, clin_only_train_CV, outcomes_avail, currTrainIdx)
mf_only_self_val<-predict_caret_models(mf_only_models, mf_only_train_CV, outcomes_avail, currTrainIdx)
combined_self_preds[[i]] <- combined_self_val
clin_only_self_preds[[i]]  <- clin_only_self_val
mf_only_self_preds[[i]] <- mf_only_self_val
# Predict outcomes on testing data using trained models
combined_test_val<-predict_caret_models(combined_models, combined_test_CV, outcomes_avail, currTestIdx)
clin_only_test_val<-predict_caret_models(clin_only_models, clin_only_test_CV, outcomes_avail, currTestIdx)
mf_only_test_val<-predict_caret_models(mf_only_models, mf_only_test_CV, outcomes_avail, currTestIdx)
combined_predictions[[i]] <- combined_test_val
clin_only_predictions[[i]] <- clin_only_test_val
mf_only_predictions[[i]] <- mf_only_test_val
}
outList1 <-
list(
combined_predictions,
clin_only_predictions,
mf_only_predictions
)
names(outList1) <-
c(
"combined_predictions",
"clin_only_predictions",
"mf_only_predictions"
)
outList2 <-
list(
combined_self_preds,
clin_only_self_preds,
mf_only_self_preds
)
names(outList2) <-
c(
"combined_self_preds",
"clin_only_self_preds",
"mf_only_self_preds"
)
finalOutList <- list(outList1,outList2)
return(finalOutList)
}
auc_dis_plots<-get_auc_plots(auc_dis,auc_dis_ci)
auc_12m_plots<-get_auc_plots(auc_12m,auc_12m_ci)
setwd(generateRootDir())
save_plot(do.call(plot_grid, c(unlist(auc_dis_plots, recursive = F), ncol=2,align='hv')), file="auc_dis.pdf",
ncol=2,base_asp = 1.1,base_height=12, base_width=5)
save_plot(do.call(plot_grid, c(unlist(auc_12m_plots, recursive = F), ncol=2,align='hv')), file="auc_12m.pdf",
ncol=2,base_asp = 1.1,base_height=12, base_width=5)
setwd('../../scripts')
get_auc_cp <- function(cps_set){
outputDF <- data.frame()
for (i in 1:length(cps_set)){
curr_pred_space <- cps_set[[i]]
curr_pred_space_name <- names(cps_set)[i]
no_classifiers <- length(curr_pred_space$Fold1)
classifier_names <- names(curr_pred_space$Fold1)
value_DF <- data.frame()
for (j in 1:no_classifiers){
values <- c()
for (m in 1:length(curr_pred_space)){
curr_cp <- curr_pred_space[[m]][[j]]
values <- c(values,curr_cp$AUC)
}
newRow<-data.frame(classifier = classifier_names[j],
mean_value = mean(values),
std_value = sd(values),
values)
value_DF <- rbind(value_DF,newRow)
}
outputDF <- rbind(outputDF,data.frame(value_DF,pred_space=curr_pred_space_name))
}
return(outputDF)
}
source('./functions/get_auc_cp.R')
auc_dis_cp <- get_auc_cp(cps_dis)
auc_12m_cp <- get_auc_cp(cps_12m)
plot_metric_stripcharts(auc_dis,"AUC (Dis)",'auc_dis.png')
plot_metric_stripcharts(auc_12m,"AUC (12m)",'auc_12m.png')
auc_12m
plot_metric_stripcharts(auc_dis_cp,"AUC (Dis)",'auc_dis.png')
plot_metric_stripcharts(auc_12m_cp,"AUC (12m)",'auc_12m.png')
